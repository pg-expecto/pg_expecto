extend|Оптимизация ожиданий extend Табличное партиционирование: Разбейте большую таблицу с высокой частотой вставок на несколько меньших по логическому правилу.Это позволяет разным операциям INSERT работать с разными физическими разделами и получать блокировки extend на разных объектах. Настройка Fillfactor: Если событие extend вызвано в основном операциями UPDATE, уменьшите параметр FILLFACTOR для таблицы.Это оставляет больше свободного места на страницах, позволяя UPDATE размещать новые версии строк на той же странице и уменьшая необходимость в ее расширении. Важно:Слишком низкий FILLFACTOR увеличивает объем занимаемого места. Проверка пропускной способности в облачной среде: В облачных средах задержки хранилища из-за недостаточной сетевой пропускной способности могут искусственно удлинять операции ввода-вывода, включая extend.Проверьте соответствующие метрики (например, WriteLatency и WriteThroughput ) и при необходимости масштабируйте инстанс. pg_expecto© 2025
BufferIo|Оптимизация ожиданий BufferIo Настройка параметров сервера 1.Недостаток памяти Мало shared_buffers Действие Увеличьте shared_buffers. 2.Частые контрольные точки Резкие всплески I/O-нагрузки Действие Увеличьте checkpoint_timeout и max_wal_size, чтобы растянуть запись данных во времени. 3.Медленные операции сортировки Использование диска вместо памяти Действие Настройте work_mem для операций сортировки и хеширования, чтобы они выполнялись в оперативной памяти. 3.Медленные операции сортировки Использование диска вместо памяти Действие Настройте work_mem для операций сортировки и хеширования, чтобы они выполнялись в оперативной памяти. 4.Медленные операции обслуживания VACUUM, CREATE INDEX Действие Увеличьте maintenance_work_mem для ускорения операций обслуживания, таких как вакуумирование и создание индексов. 5.Низкая параллельность I/O Диски не используются на полную Действие Для дисков SSD увеличьте параметр effective_io_concurrency. Оптимизация запросов и схемы базы данных Боритесь с вздутием индексов (Index Bloat): Вздутые индексы заставляют PostgreSQL читать с диска больше страниц данных, чем необходимо.Регулярно проводите REINDEX для проблемных индексов. Сделайте автовакуум более агрессивным: Высокий уровень обновлений и удалений приводит к накоплению "мертвых" строк и вздутию.Уменьшите параметры autovacuum_vacuum_scale_factor и autovacuum_analyze_scale_factor, чтобы автовакуум запускался чаще. Устраните последовательные сканирования (Sequential Scans): Создавайте индексы для столбцов, используемых в условиях WHERE, чтобы заменять полные сканирования таблиц на быстрые индексные. Используйте партиционирование: Для очень больших таблиц партиционирование помогает сократить объем данных, с которыми работает запрос, уменьшая нагрузку на буферный кеш. pg_expecto© 2025
DataFileWrite|Оптимизация ожиданий DataFileWrite Методы оптимизации Следующие методы помогут уменьшить количество и влияние событий DataFileWrite. Оптимизация контрольных точек и фоновой записи Контрольные точки — это моменты, когда все измененные ("грязные") страницы данных записываются на диск, что может вызвать всплеск нагрузки на I/O. Увеличьте checkpoint_timeout:Установите более длительный интервал между контрольными точками (например, до 1h).Это уменьшает частоту массовой записи данных на диск. Настройте checkpoint_completion_target:Установите значение около 0.9.Это помогает "растянуть" запись данных, происходящую во время контрольной точки, на почти все время до следующей контрольной точки, сглаживая нагрузку на диск. Настройте фоновую запись (bgwriter): Процесс bgwriter записывает грязные страницы фоновом режиме, чтобы основным процессам реже приходилось делать это самим, уменьшая задержки. Настройка памяти и кэширования Правильная настройка памяти позволяет реже записывать данные на диск. Увеличьте shared_buffers:Это основной кэш данных PostgreSQL.Увеличьте его до 25% от объема оперативной памяти сервера.Больший кэш позволяет дольше хранить измененные страницы в памяти, прежде чем они будут записаны на диск фоновыми процессами. Настройте wal_buffers:Увеличьте объем памяти для буферизации записей в WAL (Write-Ahead Log), особенно при высокой одновременной нагрузке.Это может снизить частоту записи WAL на диск. Оптимизация рабочих нагрузок и запросов Избегайте массовых изменений в пиковые часы:Большие пакетные UPDATE или INSERT создают много грязных страниц.По возможности выполняйте их в периоды низкой нагрузки. Оптимизируйте VACUUM и CREATE INDEX:Эти операции обслуживания интенсивно работают с диском.Увеличьте параметр maintenance_work_mem, чтобы операции вроде создания индексов выполнялись быстрее и, возможно, с меньшим количеством промежуточных записей. pg_expecto© 2025
DataFileRead|Оптимизация ожиданий DataFileRead 1.Настройка памяти Конкретные действия Увеличить параметр shared_buffers Настроить work_mem для предотвращения операций на диске. 2.Оптимизация запросов и индексов Конкретные действия Добавить индексы для замены последовательных сканирований на индексные. Анализировать и переписывать "тяжелые" запросы. Использовать партиционирование больших таблиц. 3.Управление обслуживанием БД Конкретные действия Настроить и сделать более агрессивным автовакуум (autovacuum). Выполнять операции обслуживания (VACUUM, ANALYZE) в часы низкой нагрузки. 4.Масштабирование Конкретные действия Рассмотреть увеличение ресурсов инстанса БД (больше RAM, более быстрый диск) Использовать горячие реплики для распределения read-нагрузки. Основные направления оптимизации Увеличьте эффективность кэширования Настройте shared_buffers:Этот параметр определяет, какой объем оперативной памяти PostgreSQL использует для кэширования данных.Если DataFileRead встречается часто, ваш буфер может быть слишком мал для рабочей нагрузки.Значение можно увеличить, но обычно не рекомендуется устанавливать его более 25% от общей памяти системы. Настройте work_mem:Этот параметр определяет объем памяти для операций сортировки и хеширования.Если его не хватает, PostgreSQL начинает использовать временные файлы на диске, что замедляет выполнение.Адекватная настройка work_mem позволяет выполнять эти операции в памяти. Устраните узкие места в запросах и схемах Боритесь с последовательными сканированиями (Sequential Scans):Если запросы выполняют полное сканирование больших таблиц, создайте индексы для столбцов, указанных в условиях WHERE.Это самый эффективный способ сокращения DataFileRead. Устраните вздутие индексов (Index Bloat): При интенсивных операциях обновления и удаления индексы могут "вздуваться", занимая много места и снижая эффективность.Переиндексация (REINDEX) таких индексов может радикально улучшить производительность, как в одном из реальных случаев. Используйте партиционирование:Для очень больших таблиц партиционирование позволяет запросам обращаться только к нужным разделам, что значительно сокращает объем данных, читаемых с диска. Настройте автоматическое обслуживание Агрессивный автовакуум:Высокий уровень обновлений и удалений приводит к накоплению "мертвых" строк, которые должен очищать автовакуум.Если он не успевает, это приводит к вздутию таблиц и индексов.Уменьшение параметров autovacuum_vacuum_scale_factor и autovacuum_analyze_scale_factor делает автовакуум более частым и эффективным. pg_expecto© 2025
ProcArray|Оптимизация ожиданий ProcArray Меры по снижению ожиданий ProcArray ProcArray ожидания в PostgreSQL обычно связаны с конкурентным доступом к общим структурам данных и могут указывать на нехватку вычислительных ресурсов CPU.Для снижения таких событий можно оптимизировать рабочую нагрузку, настроить параметры СУБД Оптимизация рабочих нагрузок и транзакций:Сократите время выполнения транзакций и оптимизируйте запросы, чтобы уменьшить нагрузку на процессор и общие структуры данных.Длительные транзакции дольше удерживают блокировки и увеличивают конкуренцию за ProcArray. Настройка параметров PostgreSQL:Убедитесь, что параметры max_connections установлены разумно.Избыток подключений увеличивает конкуренцию.Используйте пулер соединений (например, PgBouncer) для эффективного управления множеством клиентских подключений. pg_expecto© 2025
transactionid|Оптимизация ожиданий transactionid Ожидания типа transactionid в PostgreSQL обычно указывают на конкуренцию за строковые блокировки между транзакциями.Чтобы решить эту проблему, нужно найти источник блокировок и оптимизировать рабочую нагрузку. Понимание и диагностика проблемы Ожидание Lock:transactionid возникает, когда транзакция не может получить блокировку строки, уже удерживаемую другой транзакцией.Это характерно для конфликтующих операций UPDATE, SELECT … FOR UPDATE и SELECT … FOR KEY SHARE. Способы уменьшения ожиданий Оптимизация транзакций и приложения Избегайте длительных транзакций:Сокращайте время выполнения транзакций, особенно тех, которые изменяют данные.Чем дольше транзакция удерживает блокировки, тем выше вероятность возникновения очередей. Управляйте «idle in transaction»-сессиями:Следите за сессиями в состоянии idle in transaction, которые часто возникают из-за неподтвержденных транзакций.Всегда завершайте транзакции (COMMIT или ROLLBACK) сразу после выполнения операций.Включите autocommit в приложении, где это возможно. Пересмотрите логику блокировок:Используйте SELECT … FOR UPDATE NOWAIT или SELECT … FOR UPDATE SKIP LOCKED, чтобы приложение не застревало в ожидании.Оптимизируйте модель данных и рабочие процессы, чтобы минимизировать конкуренцию за одни и те же строки. Настройка мониторинга и обслуживания Настройте автоочистку (autovacuum):Убедитесь, что autovacuum работает эффективно, чтобы своевременно удалять старые версии строк. Контролируйте подготовленные транзакции:Регулярно проверяйте наличие старых подготовленных транзакций, которые могут удерживать блокировки, и принудительно завершайте их. Используйте пулер соединений:Для высоконагруженных систем используйте пулеры соединений (например, PgBouncer), чтобы ограничить количество одновременных подключений и снизить конкуренцию. pg_expecto© 2025
BufferContent|Оптимизация ожиданий BufferContent Ожидания типа BufferContent (также известные как LWLock:buffer_content) в PostgreSQL возникают из-за конкуренции процессов за доступ к одним и тем же данным в оперативной памяти.Чтобы уменьшить количество этих событий, необходимо оптимизировать работу с буферным кэшем и снизить конкуренцию. Происхождение и причины ожиданий Ожидание BufferContent — это легковесная блокировка (LWLock), которая защищает содержимое буферов в общей памяти: Разделяемый доступ (Shared Lock):Несколько процессов могут одновременно читать одни и те же данные. Эксклюзивный доступ (Exclusive Lock):Только один процесс может изменять данные, блокируя всех остальных. Основные причины увеличения таких ожиданий: Конкурентные обновления:Множество сессий одновременно пытаются изменить одни и те же данные, особенно в таблицах с большим количеством индексов. Неэффективная работа с памятью:Данные, необходимые рабочей нагрузке, не находятся в памяти, и процессам приходится выполнять медленные операции дискового ввода-вывода, дольше удерживая блокировки. Внешние ключи:Проверка ограничений внешнего ключа требует разделяемой блокировки на странице, на которую ссылаются, и может увеличить время удержания блокировки BufferContent. Способы уменьшения ожиданий Улучшение эффективности памяти Увеличьте размер буферного кэша:Основной параметр — shared_buffers.Убедитесь, что он достаточно велик для вашей рабочей нагрузки. Контролируйте эффективность кэша:Следите за метрикой BufferCacheHitRatio, которая показывает процент запросов, обслуживаемых из памяти.Низкое значение указывает на необходимость увеличения памяти или оптимизации запросов. Масштабируйте вычислительные ресурсы:Рассмотрите возможность увеличения размера экземпляра БД (scale-up), чтобы в памяти могла разместиться большая часть рабочего набора данных. Оптимизация схемы и индексов Удалите неиспользуемые и дублирующиеся индексы:Каждый индекс увеличивает объем данных, которые необходимо блокировать при изменении строки. Используйте частичные индексы:Если это применимо, они уменьшают размер индекса и, соответственно, объем данных для блокировки. Боритесь с раздуванием (Bloat):Раздутые таблицы и индексы занимают больше места в памяти и на диске.Для устранения проблемы используйте VACUUM FULL (блокирующий оператор) или pg_repack (неблокирующий), а для индексов — REINDEX. Оптимизация рабочей нагрузки Снизьте конкуренцию за "горячие" данные:Если приложение часто обновляет одни и те же строки (например, счетчики), можно пересмотреть логику приложения. Уменьшите использование внешних ключей:Если высокая производительность критична, проанализируйте, можно ли удалить некоторые ограничения внешнего ключа без ущерба для целостности данных. pg_expecto© 2025
WALInsert|Оптимизация ожиданий WALInsert Ожидания типа WALInsert в PostgreSQL связаны с конкуренцией за легковесную блокировку (LWLock), которая защищает процесс записи данных в буферы WAL (Write-Ahead Log) в общей памяти.Чтобы уменьшить количество этих событий, нужно оптимизировать работу с WAL и снизить конкуренцию. Способы уменьшения ожиданий WALInsert Увеличьте размер буфера WAL Основной параметр -wal_buffers.Если WAL-буфер слишком мал для текущей нагрузки, данным приходится чаще сбрасываться на диск, что увеличивает конкуренцию за блокировку WALInsert.Увеличение этого параметра позволяет буферу вместить больше данных перед записью на диск. Настройте групповой коммит (Group Commit) Используйте параметры commit_delay и commit_siblings.При правильной настройке они позволяют нескольким транзакциям объединить свои операции записи WAL в одну, снижая общее количество операций ввода-вывода и конкуренцию за блокировку.Активация требует осторожности, так как может немного увеличить задержку. Оптимизируйте рабочую нагрузку Снижение частоты коммитов:Если приложение делает очень много мелких транзакций, рассмотрите возможность объединения операций в более крупные транзакции (где это логически допустимо). Контроль длительных транзакций:Следите за сессиями в состоянии idle in transaction.Они могут удерживать ресурсы и косвенно влиять на общую производительность WAL. Обеспечьте достаточную производительность дисковой подсистемы Ожидания WALInsert могут быть следствием медленной записи WAL-файлов на диск (ожиданий IO:WALWrite).Убедитесь, что диск, на котором расположена pg_wal, обладает низкой латентностью и высокой скоростью записи. pg_expecto© 2025
BufferMapping|Оптимизация ожиданий BufferMapping Ожидание BufferMapping в PostgreSQL связано с конкуренцией за доступ к буферному кэшу.Это происходит, когда несколько процессов одновременно пытаются найти, загрузить или удалить блоки данных в общей памяти.Для уменьшения количества этих событий необходим комплексный подход. Рекомендации по устранению ожиданий BufferMapping Настройка памяти Мероприятия:Увеличить параметр shared_buffers.Мониторить blks_hit и blks_read. Ожидаемый эффект:Снижение частоты замены буферов и операций ввода-вывода Оптимизация схемы и индексов Мероприятия:Бороться с раздутостью (Bloat) таблиц и индексов; Проверить актуальность статистики и оптимизировать индексы Ожидаемый эффект:Уменьшение объема данных, считываемых в кэш pg_expecto© 2025
LockManager|Оптимизация ожиданий LockManager Ожидания типа LockManager в PostgreSQL относятся к легковесным блокировкам (LWLock), которые защищают операции с тяжеловесными блокировками. Шаги по диагностике и устранению Поскольку конкретные решения в найденных источниках отсутствуют, следующие рекомендации составлены на основе общей практики оптимизации PostgreSQL. 1.Определите контекст возникновения ожиданий. Ожидание LockManager связано с менеджером блокировок.Необходимо выяснить, какие именно запросы выполняются в момент появления этого ожидания.Анализ этих запросов — первый шаг к пониманию причины. 2.Проанализируйте общую конкуренцию за блокировки. Высокая частота ожиданий LockManager может быть симптомом общей проблемы с большим количеством конкурентных блокировок. 3.Оптимизируйте рабочую нагрузку. Часто причиной конкуренции являются длительные транзакции, удерживающие блокировки, или приложение, использующее избыточные уровни блокировки.Сокращение времени выполнения транзакций и пересмотр логики блокировок в приложении могут значительно снизить нагрузку на менеджер блокировок. pg_expecto© 2025
SpinDelay|Оптимизация ожиданий SpinDelay  Ожидания типа SpinDelay связаны с механизмом спин-блокировок (spinlocks) в PostgreSQL, которые защищают критические участки кода в разделяемой памяти. Общие рекомендации по настройке Снижение общей конкуренции:Ожидания SpinDelay часто являются симптомом высокой конкуренции за доступ к структурам разделяемой памяти.Способы снижения конкуренции включают оптимизацию запросов, устранение узких мест в рабочих нагрузках и настройку параметров, управляющих доступом к памяти. Настройка параметров памяти:Исследуйте возможность корректировки параметров, влияющих на работу с памятью, таких как shared_buffers.Их увеличение может снизить конкуренцию. Обновление PostgreSQL:Поскольку SpinDelay был явно добавлен в PostgreSQL 16, использование актуальных версий СУБД может предоставить более совершенные механизмы управления блокировками. pg_expecto© 2025
ParallelHashJoin|Оптимизация ожиданий ParallelHashJoin  Ожидания wait_event = ParallelHashJoin в PostgreSQL возникают при выполнении параллельных хэш-соединений и указывают на то, что процессы координируют свою работу или ожидают друг друга.Чтобы уменьшить количество этих событий, нужно оптимизировать использование памяти и параллельных операций. Настройка параметров памяти и параллелизма Основная причина ожиданий ParallelHashJoin — нехватка оперативной памяти для построения хэш-таблиц во время выполнения соединения. Увеличьте объем оперативной памяти (work_mem)  Каждый участник параллельного запроса (лидер и воркеры) может использовать до work_mem памяти для своей операции.Если хэш-таблица не помещается в память, PostgreSQL начинает записывать данные на диск (partitioning), что приводит к ожиданиям синхронизации между процессами.Увеличив work_mem, вы можете избежать этого. Настройте множитель памяти для хэш-операций (hash_mem_multiplier) Начиная с PostgreSQL 13, этот параметр позволяет хэш-операциям использовать больше памяти, чем стандартный лимит work_mem.Финальный лимит вычисляется как work_mem * hash_mem_multiplier. Значение по умолчанию — 2.0.Если вы видите много операций, которые пишут на диск, необходимо увеличить этот множитель. Контролируйте уровень параллелизма max_parallel_workers_per_gather:Этот параметр определяет максимальное число рабочих процессов, которые можно использовать для одной операции Gather.Слишком высокое значение может привести к чрезмерному потреблению памяти и конкуренции за CPU.Сравните планы выполнения запроса с разными значениями этого параметра (включая 0) с помощью EXPLAIN ANALYZE, чтобы найти оптимальный баланс. max_parallel_workers:Убедитесь, что общее количество доступных параллельных воркеров в системе достаточно для вашей рабочей нагрузки. Оптимизация запросов и схемы базы данных Помимо настройки параметров, важно оптимизировать сами запросы и структуру данных. Пересмотрите необходимость параллелизма для конкретных запросов:Если запрос выполняется быстро или обрабатывает небольшой объем данных, накладные расходы на организацию параллельного выполнения могут превысить выгоду.Для таких запросов можно принудительно отключить параллелизм на уровне запроса с помощью SET max_parallel_workers_per_gather = 0; или используя подсказки pg_hint_plan. Убедитесь в эффективности плана запроса:Используйте EXPLAIN (ANALYZE, BUFFERS) для анализа.Устаревшая статистика или раздутые (bloated) индексы могут заставить оптимизатор выбирать неэффективные планы с чрезмерным параллелизмом.Регулярно выполняйте VACUUM и ANALYZE для поддержания актуальной статистики Проверьте наличие адекватных индексов:Хотя Parallel Hash Join часто используется для соединения больших таблиц при отсутствии подходящих индексов, наличие правильных индексов может привести к тому, что оптимизатор выберет более быстрый план (например, Nested Loop с индексным сканированием), который не будет вызывать ожиданий ParallelHashJoin. Итог и дополнительные рекомендации Ожидания ParallelHashJoin — это нормальная часть работы параллельных запросов, но их чрезмерное количество указывает на проблемы с распределением ресурсов. Действуйте комплексно:Начните с увеличения work_mem и настройки hash_mem_multiplier, так как это наиболее прямой способ предотвратить запись на диск.Затем проанализируте и оптимизируйте проблемные запросы, отключая параллелизм там, где он не нужен. Помните о балансе:Увеличивая лимиты памяти для одного запроса, вы можете уменьшить доступную память для других одновременных операций в системе.Настройка должна быть сбалансированной. pg_expecto© 2025
ParallelFinish|Оптимизация ожиданий ParallelFinish Общее представление о событии ParallelFinish Ожидание ParallelFinish обычно связано с этапом завершения параллельных запросов.Это указывает на то, что процесс-лидер собирает и объединяет результаты, полученные от рабочих процессов.Значительное время ожидания по этому типу может сигнализировать о неэффективности в выполнении параллельных операций. Возможные направления для оптимизации Для снижения времени ожидания ParallelFinish вы можете исследовать следующие аспекты вашей базы данных и рабочих нагрузок: Анализ и оптимизация проблемных запросов Используйте EXPLAIN (ANALYZE, BUFFERS) для запросов, которые показывают высокие ожидания ParallelFinish.Обратите внимание на этапы в плане выполнения, которые потребляют больше всего времени. Убедитесь, что статистика по таблицам актуальна, выполнив команду ANALYZE.Устаревшая статистика может заставить оптимизатор принимать плохие решения о параллельном выполнении. Настройка параметров параллелизма max_parallel_workers_per_gather:Этот параметр ограничивает количество рабочих процессов, которые можно использовать для одной операции.Если он установлен слишком высоко, накладные расходы на координацию могут превысить выгоду от параллелизма.Попробуйте поэкспериментировать с этим значением. parallel_setup_cost и parallel_tuple_cost:Эти параметры влияют на решение оптимизатора о использовании параллельных планов.Их корректировка может помочь в случаях, когда параллельный запрос оказывается менее эффективным, чем последовательный. work_mem:Увеличение этого параметра может помочь операциям вроде сортировки и хэширования выполняться в памяти, а не на диске, что повышает эффективность как отдельных процессов, так и их финального агрегирования. Проверка системных ресурсов и конфигурации Убедитесь, что на сервере достаточно процессорных мощностей и оперативной памяти для обработки параллельных рабочих нагрузок без contention (соревнования за ресурсы). Ожидания, связанные с вводом-выводом (например, IO), также могут косвенно влиять на ParallelFinish.Мониторинг метрик дисковой подсистемы может помочь выявить эту проблему. Пересмотр необходимости параллелизма Для некоторых запросов, особенно тех, которые и так выполняются быстро, накладные расходы на организацию параллельного выполнения могут быть неоправданны.В таких случаях можно принудительно отключить параллельное выполнение для конкретного запроса, используя, например, SET max_parallel_workers_per_gather = 0; в начале транзакции или с помощью подсказок pg_hint_plan. pg_expecto© 2025
ExecuteGather|Оптимизация ожиданий ExecuteGather Ожидание ExecuteGather связано с выполнением параллельных запросов в PostgreSQL, когда ведущий процесс ожидает результаты от своих рабочих процессов.Для уменьшения этих событий нужно оптимизировать параллельные операции и обеспечить достаточность системных ресурсов. Основные направления оптимизации Ключевые шаги, которые помогут снизить время ожидания ExecuteGather: Нагрузка на CPU и диск CPU:ExecuteGather возникает, когда ведущий процесс параллельного запроса ожидает данные от рабочих процессов.Убедитесь, что общее количество параллельных процессов не приводит к полной загрузке процессоров.Суммарное количество параллельных воркеров в системе ограничено параметрами max_worker_processes и max_parallel_workers. Диск I/O:Параллельные запросы создают повышенную нагрузку на подсистему ввода-вывода.Убедитесь, что ваша дисковая система способна выдержать такую нагрузку без существенных задержек. Параметры параллелизма max_parallel_workers_per_gather:Этот параметр ограничивает количество рабочих процессов, которые могут быть использованы для одной операции Gather.Слишком высокое значение может создать чрезмерную конкуренцию за ресурсы.Проверьте, не установлено ли оно неоправданно высоко. Общие ограничения:Убедитесь, что значения параметров max_worker_processes и max_parallel_workers достаточно велики для запрашиваемого уровня параллелизма, но не исчерпывают все ресурсы системы. Анализ и оптимизация проблемных запросов EXPLAIN (ANALYZE):Проанализируйте план выполнения запросов, которые часто вызывают ожидания ExecuteGather.Обратите внимание на оценку стоимости и фактическое количество возвращаемых строк. Необходимость параллелизма:Для некоторых запросов, особенно тех, которые и так выполняются быстро, накладные расходы на организацию параллельного выполнения могут превышать выгоду.В таких случаях можно принудительно отключить параллельное выполнение для конкретного запроса с помощью SET max_parallel_workers_per_gather = 0; pg_expecto© 2025
BgWorkerShutdown|Оптимизация ожиданий BgWorkerShutdown Общее представление о проблеме Ожидание BgWorkerShutdown связано с завершением работы фоновых процессов (background workers) в PostgreSQL. Одна из причин роста ожиданий BgWorketShutdown:отсутствие индексов для больших таблиц  Симптомы: Сильная корреляция ожиданий СУБД с типами ожидания IO/IPC Использование метода доступа Seq Scan / Parallel Seq Scan совместно с использованием параллельных процессов( Workers Planned ,Workers Launched ) в плане выполнения запросов pg_expecto© 2025
DataFileExtend|Оптимизация ожиданий DataFileExtend Чтобы уменьшить количество событий ожидания DataFileExtend в PostgreSQL, которое возникает при расширении файлов данных, можно оптимизировать настройки базы данных, изменить подход к хранению и проанализировать рабочие нагрузки. Настройка параметров хранения и обслуживания Расширение файлов часто происходит при вставке новых данных.Правильная настройка системы может сделать этот процесс более эффективным. Увеличьте maintenance_work_mem Этот параметр определяет объем памяти, доступный для операций обслуживания, таких как VACUUM и CREATE INDEX.Больший объем памяти позволяет VACUUM эффективнее работать и быстрее освобождать пространство, помеченное для повторного использования, что снижает необходимость в расширении файлов. Оптимизируйте autovacuum Убедитесь, что фоновый процесс autovacuum активен и работает эффективно.Он отвечает за очистку "мертвых" строк.Если он отстает, таблицы будут занимать больше места, чем необходимо, но новые данные все равно могут вызывать расширение файлов. Оптимизация схемы таблиц и стратегии хранения Проактивное управление пространством может значительно снизить количество мелких операций расширения. Используйте последовательности вставки Если в вашей рабочей нагрузке преобладают последовательные вставки, это может приводить к постоянному расширению файлов в "хвосте" таблицы.В таком случае стратегия управления, описанная выше, является основным инструментом. Предварительное выделение места Cтандартной практикой является создание таблиц с запасом места (например, с использованием WITH (autovacuum_enabled=false, ...) для начального наполнения) или использование pg_prewarm для загрузки данных в кеш.Это может помочь сократить количество мелких расширений файлов. Анализ рабочей нагрузки и проблемных запросов События DataFileExtend часто являются симптомом, а не причиной.Ключ к долгосрочному решению — найти корень проблемы. Запросы, вызывающие рост данных  SQL-запросы с наибольшим количеством вставок, обновлений или временем выполнения. Корреляционный анализ  Можно напрямую связать события ожидания DataFileExtend с конкретными SQL-запросами.Это позволяет целенаправленно оптимизировать те запросы, которые больше всего влияют на рост данных. Инфраструктура Проблемы с производительностью диска (высокий iowait) могут усугублять влияние любых операций ввода-вывода, включая DataFileExtend.Убедитесь, что подсистема хранения работает оптимально. pg_expecto© 2025
relation|Оптимизация ожиданий relation Чтобы уменьшить количество событий ожидания wait_event=Relation в PostgreSQL, которые связаны с блокировками на уровне таблиц и индексов, нужно выявить и устранить их причины.Вот пошаговая стратегия для диагностики и оптимизации. Диагностика проблем с блокировками Первый шаг — определить, какие именно процессы блокируются и кто их блокирует. 1.Поиск заблокированных процессов 2.Определение блокирующих процессов и отношений Методы уменьшения ожиданий Relation После выявления проблем можно применить следующие решения. -Установите таймаут для блокировок: Чтобы предотвратить вечное ожидание, установите параметр lock_timeout.Это разрывает блокировки по истечении времени. -Оптимизируйте длительные транзакции: Длинные транзакции удерживают блокировки долгое время.Разбейте большие пакетные операции на более мелкие. -Используйте индексы для операций DML: Операции UPDATE и DELETE часто блокируют таблицы.Создание индексов для столбцов в условии WHERE позволяет использовать индексные сканирования, что сокращает объем блокируемых данных и длительность блокировок. -Создавайте индексы без блокировок: Чтобы не прерывать работу приложения, создавайте индексы с опцией CONCURRENTLY. -Снижайте уровень изоляции транзакций (с осторожностью): Уровень изоляции READ COMMITTED использует менее строгие блокировки, чем REPEATABLE READ и SERIALIZABLE.Изменение уровня может увеличить параллелизм, но требует тщательной проверки на сохранение целостности данных. -Настройте автовакуум: Накопление «мертвых» tuple (вздутие) увеличивает время операций VACUUM, UPDATE и DELETE, продлевая блокировки.Сделайте автовакуум более агрессивным. Заключение Ожидания типа Relation — это часть нормальной работы PostgreSQL, но их большое количество указывает на проблемы с параллелизмом.Системный подход к диагностике и применение указанных методов оптимизации позволят значительно улучшить ситуацию. pg_expecto© 2025
BufferPin|События ожидания BufferPin в PostgreSQL возникают, когда процессу требуется монопольный доступ к буферу (блок данных в памяти), который в этот момент «закреплен» другим процессом.Чтобы снизить частоту этих событий, нужно оптимизировать работу с буферным кешем и управление транзакциями. Понимание и диагностика проблемы Что такое BufferPin? Когда процесс в PostgreSQL читает или изменяет данные, он помещает страницы с диска в общий буферный кеш и «закрепляет» буфер (увеличивает счетчик pin count), чтобы он не был вытеснен до завершения операции.Если другому процессу нужен эксклюзивный доступ к этому же буферу (например, для записи изменений), он будет ждать, и это ожидание отображается как BufferPin. Методы снижения количества BufferPin ожиданий Способы решения этой проблемы можно разделить на несколько ключевых направлений. Причина Долгие транзакции и подтранзакции Механизм работы Транзакция удерживает закрепление на буферах до своего завершения. Практические действия Сократить время транзакций, избегать SAVEPOINT и избыточных подтранзакций в PL-коде. Причина Неоптимальные запросы Механизм работы Запросы, читающие большие объемы данных, надолго занимают буферы. Практические действия Оптимизировать запросы: добавить индексы, переписать с использованием SELECT FOR UPDATE только при необходимости. Причина Недостаток памяти Механизм работы Маленький кеш приводит к частому вытеснению буферов и повторному чтению с диска. Практические действия Увеличить параметр shared_buffers Причина Высокая конкуренция Механизм работы Много одновременных запросов конкурируют за ограниченный набор горячих данных. Практические действия Настроить max_connections и использовать пул соединений Дополнительные рекомендации Настройка autovacuum: Долгие транзакции могут блокировать VACUUM, в том числе и операции с BufferPin.Следите, чтобы автоочистка работала эффективно. pg_expecto© 2025
Extension|Ожидания типа Extension в PostgreSQL связаны с работой расширений базы данных, и информация о конкретных причинах и способах их устранения в предоставленных результатах поиска ограничена. Поскольку ожидание Extension указывает, что процесс находится в состоянии ожидания, вызванного модулем расширения, ключ к решению проблемы лежит в определении того, какое именно расширение вызывает ожидание, и в поиске информации, специфичной для этого расширения. Проверьте настройки и рабочую нагрузку: Конфигурационные параметры, относящиеся к проблемному расширению.Возможно, их настройка позволит снизить конкуренцию за ресурсы. Не создает ли ваша рабочая нагрузка чрезмерную конкуренцию за ресурсы, которыми управляет расширение. pg_expecto© 2025
Lock|Ожидания типа Lock в PostgreSQL возникают, когда транзакции конкурируют за доступ к одним и тем же данным.Чтобы уменьшить количество таких событий, нужно оптимизировать работу с блокировками на нескольких уровнях. Основные направления оптимизации 1.Оптимизация транзакций -Сократите время транзакций -чем короче транзакция, тем меньше времени удерживаются блокировки -Избегайте долгих операций в транзакциях -особенно в циклах или пакетных обработках -Используйте LOCK TIMEOUT 2.Оптимизация запросов и схемы -Создавайте индексы для столбцов в WHERE и JOIN -это уменьшает количество блокируемых строк -Используйте оптимальный порядок выполнения DML-операций во избежание взаимоблокировок -Применяйте партиционирование для уменьшения конкуренции за большие таблицы 3.Настройка уровней изоляции -Используйте READ COMMITTED вместо SERIALIZABLE, где это допустимо -Рассмотрите REPEATABLE READ для сложных транзакций, но учитывайте риски 4.Управление подключениями -Настройте пул соединений  для ограничения одновременных транзакций -Установите таймауты: idle_in_transaction_session_timeout 5.Оптимизация конкурентных операций -Используйте SELECT FOR UPDATE SKIP LOCKED для обработки очередей -Применяйте ON CONFLICT в INSERT для обработки конфликтов -Используйте курсоры с WITH HOLD для уменьшения времени блокировок Профилактические меры: -Регулярный VACUUM для предотвращения блокировок при очистке -Обновление статистики через ANALYZE -Мониторинг длительных транзакций Расширенные техники Для высоконагруженных систем: -Используйте логическую репликацию для распределения нагрузки -Рассмотрите шардинг больших таблиц -Применяйте оптимистичные блокировки через версионность pg_expecto© 2025
Timeout|Ожидание SpinDelay обычно связано с спин-блокировками (spinlocks) на очень короткие периоды, когда процесс активно крутится в цикле, ожидая освобождения низкоуровневого механизма синхронизации. Это низкоуровневый механизм, и его оптимизация часто требует глубокого понимания внутренней работы PostgreSQL. Общее направление для диагностики и оптимизации Анализ нагрузки на CPU: SpinDelay напрямую связан с использованием процессора. Высокая конкуренция за спин-блокировки может указывать на общую нехватку CPU или на то, что определенные внутренние структуры данных становятся узким местом. Обновление версии PostgreSQL: Разработчики постоянно улучшают внутренние механизмы, включая управление блокировками. Проблема, вызывающая высокую конкуренцию в вашей текущей версии, могла быть устранена в более новой. Пересмотр рабочих нагрузок: Проанализируйте, не выполняются ли у вас одновременно множество запросов, модифицирующих одни и те же структуры данных (например, частые вставки в один индекс). Иногда изменение логики приложения или выравнивание пиковых нагрузок может снизить конкуренцию. pg_expecto© 2025
DSMFillZeroWrite|Cобытие IO:DSMFillZeroWrite происходит, когда процесс ожидает записи нулей в файл бэкенда динамической разделяемой памяти (Dynamic Shared Memory). Динамическая разделяемая память (DSM) используется PostgreSQL для обмена данными между параллельными процессами, например, в операциях параллельного запроса или для фоновых рабочих процессов. Перед использованием сегмент DSM должен быть инициализирован, часто — заполнен нулями, что и приводит к событию DSMFillZeroWrite. Рекомендации по диагностике и снижению ожиданий 1. Анализ и оптимизация параллельных запросов Диагностика: Определите, какие запросы выполняются в момент возникновения ожиданий. Обращайте внимание на запросы с параллельным выполнением (в плане execution plan есть операции Gather или Gather Merge). Действия: Если параллельные запросы создают чрезмерную нагрузку, попробуйте уменьшить количество параллельных рабочих процессов с помощью параметра max_parallel_workers_per_gather для конкретного запроса или всей системы. Это может снизить нагрузку на подсистему DSM. Проверка общей нагрузки на подсистему ввода-вывода Диагностика: Ожидание DSMFillZeroWrite — это операция записи. Проверьте метрики диска (например, DiskQueueDepth в AWS RDS) на предмет общей перегрузки подсистемы ввода-вывода. Действия: Если диск перегружен, рассмотрите возможность перехода на более производительное хранилище (например, SSD). Также проанализируйте другие операции, которые могут создавать нагрузку на запись (например, интенсивная работа WAL, проверка точек сохранения - checkpoint), и при необходимости настройте их. pg_expecto© 2025
tuple|Чтобы уменьшить количество событий ожидания wait_event=tuple в PostgreSQL, необходимо устранить конкуренцию за строковые блокировки (row-level locks). Это происходит, когда несколько транзакций пытаются одновременно получить доступ к одной и той же строке. Диагностика проблемы 1.Найти блокирующие сессии 2.Проверить длительные простаивающие транзакции  Применение корректирующих действий Логика приложения	Завершить блокирующие процессы	Как краткосрочное решение, используйте SELECT pg_terminate_backend(<blocking_pid>); для принудительного завершения простаивающих блокирующих сессий. Установить таймаут простоя	Используйте параметр idle_in_transaction_session_timeout для автоматического закрытия долгих простаивающих транзакций. Использовать автокоммит	Убедитесь, что приложение использует режим автоподтверждения транзакций (autocommit), чтобы не держать транзакции открытыми без необходимости. Параллелизм и блокировки	Изменить логику	Измените логику приложения и структуру таблиц, чтобы избежать появления "горячих строк" (hot rows), которые все постоянно обновляют. Использовать NOWAIT	Добавляйте FOR UPDATE NOWAIT в запросы; приложение получит ошибку сразу, вместо того чтобы ждать, и сможет повторить попытку. Оптимистичные блокировки	Используйте столбец с номером версии или временной меткой для проверки конфликтов перед коммитом, сокращая время удержания блокировки. Настроить уровень изоляции	Рассмотрите возможность использования более низкого уровня изоляции транзакций, например Read Committed, чтобы уменьшить блокировки. Настройка системы и запросов	Увеличить ресурсы	Если конкуренция за блокировки является симптомом нехватки CPU или проблем с I/O, улучшите конфигурацию сервера или оптимизируйте тяжелые запросы. Оптимизировать запросы	Убедитесь, что все запросы используют индексы для более быстрого выполнения, что сократит время удержания блокировок. Архивировать данные	Уменьшите размер таблиц, архивируя старые данные, чтобы ускорить операции, такие как обновления и очистка (VACUUM). Ключевые выводы Немедленные действия: Используйте диагностические запросы, чтобы найти и завершить блокирующие простаивающие сеансы. Долгосрочная стратегия: Сосредоточьтесь на оптимизации логики приложения, использовании оптимистичных блокировок и обеспечении эффективности запросов. Проактивный мониторинг: Следите за системными ресурсами и установите параметр idle_in_transaction_session_timeout, чтобы предотвратить проблемы в будущем. pg_expecto© 2025
